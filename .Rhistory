# Eliminar columnas que no nos interesan
ecoliCleanData = as.data.frame(t(eColiData[, -23]))
names(ecoliCleanData) = eColiData$gene.ID
rownames(ecoliCleanData) = names(eColiData)[-23]
goodsgenes = goodSamplesGenes(ecoliCleanData, verbose = 3);
goodsgenes$allOK
if (!goodsgenes$allOK)
{
# Optionally, print the gene and sample names that were removed:
if (sum(!goodsgenes$goodGenes)>0)
printFlush(paste("Removing genes:", paste(names(ecoliCleanData)[!goodsgenes$goodGenes], collapse = ", ")));
if (sum(!goodsgenes$goodSamples)>0)
printFlush(paste("Removing samples:", paste(rownames(ecoliCleanData)[!goodsgenes$goodSamples], collapse = ", ")));
# Remove the offending genes and samples from the data:
ecoliCleanData = ecoliCleanData[goodsgenes$goodSamples, goodsgenes$goodGenes]
}
goodsgenes = goodSamplesGenes(ecoliCleanData, verbose = 3);
goodsgenes$allOK
getwd()
read.tsv()
read.table(file = 'uniprot.tsv', sep = '\t', header = TRUE)
uni <- read.table(file = 'uniprot.tsv', sep = '\t', header = TRUE)
View(uni)
View(uni)
# Cargamos el archivo de datos
data <- read.csv("uniprot1.csv", header=T, sep=";")
# Filtramos las entradas y cambiamos el Entry name
data2 <- dplyr::filter(data, grepl("HUMAN",Entry.Name))
data2$Entry.Name2 <- sapply(data2$Entry.Name, function(i) gsub("_HUMAN", "", i))
# Mapeamos con STRING
string_db <- STRINGdb$new( version="11", species=9606, score_threshold=400, input_directory="" )
data_mapped <- string_db$map(data2, "Entry", removeUnmappedRows = TRUE )
library(dplyr)
library(STRINGdb)
# Filtramos las entradas y cambiamos el Entry name
data2 <- dplyr::filter(data, grepl("HUMAN",Entry.Name))
data2$Entry.Name2 <- sapply(data2$Entry.Name, function(i) gsub("_HUMAN", "", i))
# Mapeamos con STRING
string_db <- STRINGdb$new( version="11", species=9606, score_threshold=400, input_directory="" )
data_mapped <- string_db$map(data2, "Entry", removeUnmappedRows = TRUE )
# Guardamos la red de proteinas
hits <-data_mapped$STRING_id
png("01_string_hits.png")
string_db$plot_network(hits)
dev.off()
# Cargamos el archivo de datos
data <- read.csv("uniprot1.csv", header=T, sep=";")
# Filtramos las entradas y cambiamos el Entry name
data2 <- dplyr::filter(data, grepl("HUMAN",Entry.Name))
# Mapeamos con STRING
string_db <- STRINGdb$new( version="11", species=9606, score_threshold=400, input_directory="" )
View(data2)
data_mapped <- string_db$map(data2, "Entry", removeUnmappedRows = TRUE )
data_mapped$STRING_id
View(data_mapped)
View(data_mapped)
string.network <- string_db$get_graph()
View(string.network)
View(string.network)
proteins.mapped.network <- string_db$get_subnetwork(proteins.mapped.string_ids)
proteins.mapped.string_ids <- data_mapped$STRING_id
proteins.mapped.network <- string_db$get_subnetwork(proteins.mapped.string_ids)
View(proteins.mapped.network)
View(proteins.mapped.network)
View(string.network)
View(string.network)
View(proteins.mapped.network)
View(proteins.mapped.network)
proteins.mapped.string_ids <- data_mapped$STRING_id
proteins.mapped.string_ids
string_network <- string_db$get_graph()
robustness.random2 <- function(grafo, measure=degree){
q = seq(from=0.01,to=1,by=0.01)
g = grafo
S = max(components(grafo)$csize)/vcount(grafo)
contador = S
removalset = NULL
for(i in q){
if(contador > 0.05 & length(removalset) < vcount(g)/2){
removalset <- sample(x = V(g)$name, size = 10, replace = F)
g <- delete.vertices(graph = g, v = removalset)
S = c(S, max(components(g)$csize)/vcount(grafo))
contador = max(components(g)$csize)/vcount(grafo)
}
}
x <- as.numeric(q[1:length(S)])
x <- x[!is.na(x)]
y <- as.numeric(S)
id <- order(x)
return(sum(diff(x[id])*rollmean(y[id],2)))
}
robustness.random2(string_network)
library(igraph)
library(dplyr)
library(ggplot2)
library(zoo)
proteinscovid_network
#obtenemos la red para nuestros datps
protein_covid_network <- string_db$get_subnetwork(data_mapped_string_ids )
data_mapped_string_ids <- data_mapped$STRING_id
string_network <- string_db$get_graph()
#obtenemos la red para nuestros datps
protein_covid_network <- string_db$get_subnetwork(data_mapped_string_ids )
View(protein_covid_network)
View(protein_covid_network)
robustness.random2 <- function(grafo, measure=degree){
q = seq(from=0.01,to=1,by=0.01)
g = grafo
S = max(components(grafo)$csize)/vcount(grafo)
contador = S
removalset = NULL
for(i in q){
if(contador > 0.05 & length(removalset) < vcount(g)/2){
removalset <- sample(x = V(g)$name, size = 10, replace = F)
g <- delete.vertices(graph = g, v = removalset)
S = c(S, max(components(g)$csize)/vcount(grafo))
contador = max(components(g)$csize)/vcount(grafo)
}
}
x <- as.numeric(q[1:length(S)])
x <- x[!is.na(x)]
y <- as.numeric(S)
id <- order(x)
return(sum(diff(x[id])*rollmean(y[id],2)))
}
o
robustness.random2(covid_network)
#obtenemos la red para nuestros datps
covid_network <- string_db$get_subnetwork(data_mapped_string_ids )
robustness.random2
View(robustness.random2)
View(robustness.random2)
## Robustez ataque dirigido (0.0226)
robustness.targeted2(g)
robustness.random2(g)
string_db <- STRINGdb$new(
version="11",
species=9606,
score_threshold=995,
input_directory="")
j <- string_db$get_graph()
robustness.random2(j)
robu_tar <- robustness.targeted2(g)
robu_rand <- robustness.random2(g)
robustez_tabla <- data.frame(row.names =  c("Robustez Dirigida", "Robustez Random"), c(robu_tar,robu_rand))
cat("Characteristic path length\n")
cat(paste("Scale-free: ", round(average.path.length(g),2), sep=""), "\n")
cat("Transitivity\n")
cat(paste("Scale-free: ", round(transitivity(g),2), sep=""), "\n")
### Targeted attacks
att.BA <- sequential.attacks.targeted(g)
att.BA$attack <- rep("targeted")
### Random attacks
r.att.BA <- sequential.attacks.random(g)
r.att.BA$attack <- rep("random")
attack = rbind(att.BA,r.att.BA)
### Plots
pdf(file = 'sequential_attacks.pdf', width = 8,height = 6)
ggplot(attack, aes(x=q, y=S, color=attack)) + geom_point(alpha=.4, size=2) +
theme_bw() +
theme(plot.background = element_blank(),  panel.grid.minor = element_blank(),plot.title=element_text(size=15)) +
geom_line() +
ggtitle("Targeted sequential attacks") +
ylab("S(q)") +
xlab("q")
dev.off()
pdf(file = 'random.sequential_attacks.pdf', width = 8,height = 6)
ggplot(r.att.BA, aes(x=q, y=S)) + geom_point(alpha=.4, size=2) +
theme_bw() +
theme(plot.background = element_blank(),  panel.grid.minor = element_blank(),plot.title=element_text(size=15)) +
geom_line() +
ggtitle("Random sequential attacks") +
ylab("S(q)") +
xlab("q")
dev.off()
robu_tar <- robustness.targeted2(g)
robu_rand <- robustness.random2(g)
robustez_tabla <- data.frame(row.names =  c("Robustez Dirigida", "Robustez Random"), c(robu_tar,robu_rand))
heter <- function(network) {
require(igraph)
return(var(degree(network))/mean(degree(network))
)
}
sequential.attacks.targeted <- function(grafo, measure=degree){
# Computes the size of the largest cluster as we remove vertices from high degree to low degree (relative to the original graph)
# Implements the robustness described in Schneider, C. M. & Moreira, A. A. Mitigation of malicious attacks on networks. in (2011). doi:10.1073/pnas.1009440108/-/DCSupplemental
#update the degree distribution after each node removal step
q = seq(from=0,to=1,by=0.01)
g = grafo
S = max(components(grafo)$csize)/vcount(grafo)
contador = S
removalset = NULL
v = vcount(grafo)
s = max(components(grafo)$csize)
for(i in q){
if(max(components(g)$csize)/vcount(grafo) >0.05){
removalset <- names(sort(degree(g),decreasing = T)[1:(i*vcount(g))])
g <- delete.vertices(graph = g, v = removalset)
S = c(S, max(components(g)$csize)/vcount(grafo))
v <- c(v, vcount(g))
s = c(s, max(components(g)$csize))
contador = max(components(g)$csize)/vcount(grafo)
}
}
S.vs.q <- tbl_df(data.frame(cbind(q[1:length(S)],S,s,v)))
names(S.vs.q) <- c("q", "S", "s", "v")
return(S.vs.q)
}
sequential.attacks.random <- function(grafo, measure=degree){
# Computes the size of the largest cluster as we remove vertices from high degree to low degree (relative to the original grafo)
# Implements the robustness described in Schneider, C. M. & Moreira, A. A. Mitigation of malicious attacks on networks. in (2011). doi:10.1073/pnas.1009440108/-/DCSupplemental
#update the degree distribution after each node removal step
q = seq(from=0,to=1,by=0.01)
g = grafo
S = max(components(grafo)$csize)/vcount(grafo)
contador = S
removalset = NULL
v = vcount(grafo)
s = max(components(grafo)$csize)
for(i in q){
if(contador > 0.05 & length(removalset) < vcount(g)/2){
removalset <- sample(x = V(g)$name, size = 10, replace = F)
g <- delete.vertices(graph = g, v = removalset)
S = c(S, max(components(g)$csize)/vcount(grafo))
v <- c(v, vcount(g))
s = c(s, max(components(g)$csize))
contador = max(components(g)$csize)/vcount(grafo)
}
}
S.vs.q <- tbl_df(data.frame(cbind(q[1:length(S)],S,s,v)))
names(S.vs.q) <- c("q", "S", "s", "v")
return(S.vs.q)
}
robustness.targeted2 <- function(grafo, measure=degree){
# Computes the size of the largest cluster as we remove vertices from high degree to low degree (relative to the original grafo)
# Implements the robustness described in Schneider, C. M. & Moreira, A. A. Mitigation of malicious attacks on networks. in (2011). doi:10.1073/pnas.1009440108/-/DCSupplemental
#update the degree distribution after each node removal step
# Returns the robustness of the network R = 1/No ???S(q)
# Area under the curve:
# x <- set of values
# y <- set ov values y(x)
# id <- order(x)
#
# AUC <- sum(diff(x[id])*rollmean(y[id],2))
q = seq(from=0.01,to=1,by=0.01)
g = grafo
S = max(components(grafo)$csize)/vcount(grafo)
contador = S
removalset = NULL
for(i in q){
if(max(components(g)$csize)/vcount(grafo) >0.05){
removalset <- names(sort(degree(g),decreasing = T)[1:(i*vcount(g))])
g <- delete.vertices(graph = g, v = removalset)
S = c(S, max(components(g)$csize)/vcount(grafo))
contador = max(components(g)$csize)/vcount(grafo)
}
}
x <- as.numeric(q[1:length(S)])
y <- as.numeric(S)
id <- order(x)
return(sum(diff(x[id])*rollmean(y[id],2)))
}
robustness.random2 <- function(grafo, measure=degree){
# Computes the size of the largest cluster as we remove vertices from high degree to low degree (relative to the original grafo)
# Implements the robustness described in Schneider, C. M. & Moreira, A. A. Mitigation of malicious attacks on networks. in (2011). doi:10.1073/pnas.1009440108/-/DCSupplemental
#update the degree distribution after each node removal step
# Returns the robustness of the network R = 1/No ???S(q)
# Area under the curve:
# x <- set of values
# y <- set ov values y(x)
# id <- order(x)
#
# AUC <- sum(diff(x[id])*rollmean(y[id],2))
# See more in http://stackoverflow.com/questions/4954507/calculate-the-area-under-a-curve-in-r
q = seq(from=0.01,to=1,by=0.01)
g = grafo
S = max(components(grafo)$csize)/vcount(grafo)
contador = S
removalset = NULL
for(i in q){
if(contador > 0.05 & length(removalset) < vcount(g)/2){
removalset <- sample(x = V(g)$name, size = 10, replace = F)
g <- delete.vertices(graph = g, v = removalset)
S = c(S, max(components(g)$csize)/vcount(grafo))
contador = max(components(g)$csize)/vcount(grafo)
}
}
x <- as.numeric(q[1:length(S)])
x <- x[!is.na(x)]
y <- as.numeric(S)
id <- order(x)
return(sum(diff(x[id])*rollmean(y[id],2)))
}
# plot the graph
plot_graph <- function(graph){
V(graph)$label <- NA
V(graph)$name <- NA
V(graph)$size <- degree(graph)/5
E(graph)$edge.color <- "gray80"
V(graph)$color <- "tomato"
# graph_attr(graph, "layout") <- layout_with_lgl
graph_attr(graph, "layout") <- layout.kamada.kawai
plot(graph)
}
################### End of Func
t.att.BA <- sequential.attacks.targeted(j)
t.att.BA$attack <- rep("targeted")
View(t.att.BA)
View(t.att.BA)
r.att.BA <- sequential.attacks.random(j)
r.att.BA$attack <- rep("random")
View(r.att.BA)
View(r.att.BA)
# Cargamos el archivo de datos
data <- read.csv("code/data/uniprot1.csv", header=T, sep=";")
library(igraph)
library(dplyr)
library(ggplot2)
library(zoo)
library(STRINGdb)
library(linkcomm)
setwd("C://Users//usuario//Desktop//IngSalud//Cuarto//Biologia de Sistemas//Trabajo//project_template")
# Cargamos el archivo de datos
data <- read.csv("code/data/uniprot1.csv", header=T, sep=";")
# Filtramos las entradas y cambiamos el Entry name
data2 <- dplyr::filter(data, grepl("HUMAN",Entry.Name))
data2$Entry.Name2 <- sapply(data2$Entry.Name, function(i) gsub("_HUMAN", "", i))
data_mapped <- string_db$map(data2, "Entry", removeUnmappedRows = TRUE )
string_db <- STRINGdb$new( version="11", species=9606, score_threshold=400, input_directory="" )
data_mapped <- string_db$map(data2, "Entry", removeUnmappedRows = TRUE )
data_mapped_string_ids <- data_mapped$STRING_id
# Creamos un objeto igraph
string_network <- string_db$get_graph()
# Obtenemos la red para nuestros datos
covid_network <- string_db$get_subnetwork(data_mapped_string_ids)
# Guardamos los hits de string
hits <-data_mapped$STRING_id
png("results/string_hits.png")
string_db$plot_network(hits)
dev.off()
# Primera capa de la red
primer.vecino <- (neighbors(graph = string_network, v = V(covid_network)$name, mode = "all"))$name
hits.network <- string_db$get_subnetwork(unique(c(V(covid_network)$name, primer.vecino)))
cl <- components(hits.network)
borra.nodos <- names(cl$membership[cl$membership!=1])
hits.network <- delete_vertices(hits.network, borra.nodos)
names <- gsub("9606.ENSP00000", "", V(hits.network)$name)
V(hits.network)$name <- names
deg.dist <- degree_distribution(hits.network,cumulative = F, mode="all")
png("results/degree_distribution.png")
plot( x=0:max(deg), y=1-deg.dist, pch=20, cex=1.2, col="orange", xlab="Degree", ylab="Frequency")
clusteringCoef<-transitivity(hits.network, type = "local", isolates = c("zero"))
cc_medio <- transitivity(hits.network, type = "average")
cat("El Coeficiente de Agrupación medio es de:: ",cc_medio)
clusydegree <- data.frame(degree = deg, Clust_Coef = clusteringCoef, row.names = NULL)
png("results/coeficiente_agrupamiento.png")
plot(clusydegree,pch=20, cex=1.2, col="orange", xlab="Degree", ylab="Clustering Coeffient" )
deg <- degree(hits.network, mode="all")
#Calculo el grado de distribucion y lo grafico
deg.dist <- degree_distribution(hits.network,cumulative = F, mode="all")
png("results/degree_distribution.png")
plot( x=0:max(deg), y=1-deg.dist, pch=20, cex=1.2, col="orange", xlab="Degree", ylab="Frequency")
clusteringCoef<-transitivity(hits.network, type = "local", isolates = c("zero"))
cc_medio <- transitivity(hits.network, type = "average")
cat("El Coeficiente de Agrupación medio es de:: ",cc_medio)
clusydegree <- data.frame(degree = deg, Clust_Coef = clusteringCoef, row.names = NULL)
png("results/coeficiente_agrupamiento.png")
plot(clusydegree,pch=20, cex=1.2, col="orange", xlab="Degree", ylab="Clustering Coeffient" )
plot( x=0:max(deg), y=1-deg.dist, pch=20, cex=1.2, col="orange", xlab="Degree", ylab="Frequency")
deg.dist <- degree_distribution(hits.network,cumulative = F, mode="all")
plot( x=0:max(deg), y=1-deg.dist, pch=20, cex=1.2, col="orange", xlab="Degree", ylab="Frequency")
deg.dist <- degree_distribution(hits.network,cumulative = F, mode="all")
plot( x=0:max(deg), y=1-deg.dist, pch=20, cex=1.2, col="orange", xlab="Degree", ylab="Frequency")
plot(deg.dist, x=0:max(deg), y=1-deg.dist, pch=20, cex=1.2, col="orange", xlab="Degree", ylab="Frequency")
plot(deg.dist, pch=20, cex=1.2, col="orange", xlab="Degree", ylab="Frequency")
plot(clusydegree,pch=20, cex=1.2, col="orange", xlab="Degree", ylab="Clustering Coeffient" )
clusteringCoef<-transitivity(hits.network, type = "local", isolates = c("zero"))
cc_medio <- transitivity(hits.network, type = "average")
cat("El Coeficiente de Agrupación medio es de:: ",cc_medio)
clusydegree <- data.frame(degree = deg, Clust_Coef = clusteringCoef, row.names = NULL)
plot(clusydegree,pch=20, cex=1.2, col="orange", xlab="Degree", ylab="Clustering Coeffient" )
clusteringCoef<-transitivity(hits.network, type = "local", isolates = c("zero"))
cc_medio <- transitivity(hits.network, type = "average")
cat("El Coeficiente de Agrupación medio es de:: ",cc_medio)
clusydegree <- data.frame(degree = deg, Clust_Coef = clusteringCoef, row.names = NULL)
plot(clusydegree,pch=20, cex=1.2, col="orange", xlab="Degree", ylab="Clustering Coeffient" )
deg.dist <- degree_distribution(hits.network,cumulative = F, mode="all")
plot(x=0:max(deg), y=1-deg.dist, pch=20, cex=1.2, col="orange", xlab="Degree", ylab="Frequency")
deg <- degree(hits.network, mode="all")
#Calculo el grado de distribucion y lo grafico
deg.dist <- degree_distribution(hits.network,cumulative = F, mode="all")
png("results/degree_distribution.png")
plot(deg.dist, pch=20, cex=1.2, col="orange", xlab="Degree", ylab="Frequency")
dev.off()
clusteringCoef<-transitivity(hits.network, type = "local", isolates = c("zero"))
cc_medio <- transitivity(hits.network, type = "average")
cat("El Coeficiente de Agrupación medio es de:: ",cc_medio)
clusydegree <- data.frame(degree = deg, Clust_Coef = clusteringCoef, row.names = NULL)
png("results/coeficiente_agrupamiento.png")
plot(clusydegree,pch=20, cex=1.2, col="orange", xlab="Degree", ylab="Clustering Coeffient" )
dev.off()
d <- distances(hits.network)
d <- distances(hits.network)
plot(pch=20, cex=1.2, col="orange", xlab="Degree", ylab="Frequency")
?distances
d <- distance_table(hits.network)
plot(pch=20, cex=1.2, col="orange", xlab="Degree", ylab="Frequency")
plot(d,pch=20, cex=1.2, col="orange", xlab="Degree", ylab="Frequency")
d <- distance_table(hits.network)
dt.frame <- as.data.frame(d)
plot(dt.frame,pch=20, cex=1.2, col="orange", xlab="Degree", ylab="Frequency")
d <- distance_table(hits.network)
dt.frame <- as.data.frame(d)
plot(dt.frame,pch=20, cex=1.2, col="orange", xlab="Degree", ylab="Frequency")
d <- distance_table(hits.network)
dt.frame <- as.data.frame(d)
png("results/distancia.png")
plot(dt.frame,pch=20, cex=1.2, col="orange", xlab="Degree", ylab="Frequency")
dev.off()
d
det.frame
dt.frame
d <- distance_table(hits.network)
dt.frame <- as.data.frame(d)
index <- 1:length(dt.frame$res)
s <- sum(dt.frame$res)
dt.frame$res <-dt.frame$res/s
png("results/distancia.png")
plot(dt.frame,pch=20, cex=1.2, col="orange", xlab="Degree", ylab="Frequency")
dev.off()
index
s
dt.frame
d <- distance_table(hits.network)
dt.frame <- as.data.frame(d)
index <- 1:length(dt.frame$res)
s <- sum(dt.frame$res)
dt.frame$res <-dt.frame$res/s
png("results/distancia.png")
plot(dt.frame, aes(x = index, y = res),pch=20, cex=1.2, col="orange", xlab="Degree", ylab="Frequency")
dev.off()
plot(dt.frame, x = index, y = res,pch=20, cex=1.2, col="orange", xlab="Degree", ylab="Frequency")
dev.off()
d <- distance_table(hits.network)
dt.frame <- as.data.frame(d)
index <- 1:length(dt.frame$res)
s <- sum(dt.frame$res)
dt.frame$res <-dt.frame$res/s
png("results/distancia.png")
plot(dt.frame, x = dt.frame$index, y = dt.frame$res,pch=20, cex=1.2, col="orange", xlab="Degree", ylab="Frequency")
dev.off()
d <- distance_table(hits.network)
dt.frame <- as.data.frame(d)
index <- 1:length(dt.frame$res)
s <- sum(dt.frame$res)
dt.frame$res <-dt.frame$res/s
png("results/distancia.png")
plot(dt.frame$res,pch=20, cex=1.2, col="orange", xlab="Degree", ylab="Frequency")
dev.off()
d <- distance_table(hits.network)
dt.frame <- as.data.frame(d)
png("results/distancia.png")
plot(dt.frame$res,pch=20, cex=1.2, col="orange", xlab="Degree", ylab="Frequency")
dev.off()
d
d$res
d <- distance_table(hits.network)
dt.frame <- as.data.frame(d)
indice <- 1:length(d$res)
sumatorio <- sum(d$res)
d$res <- d$res/s
png("results/distancia.png")
plot(d$res,pch=20, cex=1.2, col="orange", xlab="Degree", ylab="Frequency")
dev.off()
ggplot(d$res,pch=20, cex=1.2, col="orange", xlab="Degree", ylab="Frequency")
dev.off()
distance <- distance_table(hits.network)
denominador <- 1:length(distance$res)
sumatorio <- sum(distance$res)
distance$res <- distance$res/s
png("results/distancia.png")
plot(distance$res,pch=20, cex=1.2, col="orange", xlab="Degree", ylab="Frequency")
dev.off()
#distancia euclidea
distance <- distance_table(hits.network)
denominador <- 1:length(distance$res)
sumatorio <- sum(distance$res)
distance$res <- distance$res/s
png("results/distancia.png")
plot(distance$res,pch=20, cex=1.2, col="orange", xlab="Distancia", ylab="Pd")
dev.off()
###### distancia
distance <- distance_table(hits.network)
denominador <- 1:length(distance$res)
sumatorio <- sum(distance$res)
distance$res <- distance$res/s
png("results/distancia.png")
plot(distance$res,pch=20, cex=1.2, col="blue", xlab="Distancia", ylab="Pd")
dev.off()
###### distancia
distance <- distance_table(hits.network)
denominador <- 1:length(distance$res)
sumatorio <- sum(distance$res)
distance$res <- distance$res/s
png("results/distancia.png")
plot(distance$res,pch=20, cex=1.2, col="blue", xlab="Distancia", ylab="Pd")
dev.off()
mean_distance(distance)
mean_distance(distance$res)
mean_distance(hits.network)
distance$res <- distance$res/s
cat("La distacnia media es de: ",mean_distance(hits.network))
